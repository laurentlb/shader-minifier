// Generated with  (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SULT_EXPECTED_
# define SULT_EXPECTED_
# define VAR_resolution "r"
# define VAR_time "y"

const char *sult_frag =
 "vec3 v=vec3(1),n=vec3(0,0,1),x=vec3(0,0,1.5);"
 "uniform vec2 r;"
 "uniform float y;"
 "vec3 rotatey(vec3 v,float y)"
 "{"
   "return vec3(v.x*cos(y)+v.z*sin(y),v.y,v.z*cos(y)-v.x*sin(y));"
 "}"
 "float m=0.;"
 "float s(vec3 v)"
 "{"
   "float x=y,c,k;"
   "v+=(sin(v.zxy*1.7+x)+sin(v.yzx+x*3.))*.2;"
   "k=length(v.xyz*vec3(1,1,.1)-vec3(0,-.1,x*.15-.3))-.34;"
   "v.xy=vec2(atan(v.x,v.y)*1.113,1.6-length(v.xy)-sin(x*2.)*.3);"
   "c=max(abs(v.y-.3)-.05,abs(length(fract(v.xz)-.5)-.4)-.03);"
   "m=step(k,c);"
   "return min(min(c,k),v.y-.2);"
 "}"
 "vec3 diffdark=vec3(.19,.2,.24),k=vec3(1),z=vec3(.45,.01,0),c=vec3(.17,0,0);"
 "void main()"
 "{"
   "vec2 d=-1.+2.*gl_FragCoord.xy/r.xy;"
   "vec3 a=normalize(rotatey(rotatey(vec3(d.y*.9,d.x*.9*1.33,1),0.).yxz,(90.+0.*y)*.035)),f=n+x*y;"
   "float u=1.,l=0.,g,w,C=0.,F,p,H,G;"
   "vec3 E=vec3(.01,0,0),D=E.yyy,B;"
   "for(;u>.1;)"
     "{"
       "for(g=C,w=1.;g<10.&&w>.005;g+=w)"
         "w=s(f+a*g);"
       "if(g<10.)"
         "f+=a*g,F=s(f),H=m,B=normalize(-vec3(F-s(f+E.xyy),F-s(f+E.yxy),F-s(f+E.yyx))),p=clamp(s(f+B*.05)*4.+s(f+B*.1)*2.+.5,.1,1.),l=H*.3,B=normalize(B+step(4.,5.)*m*sin(f.yzx*40.)*.05),a=reflect(a,B),G=clamp(dot(normalize(v),B),0.,1.),B=mix(mix(diffdark,k,G),z*(G+.2),H)+vec3(.7*pow(clamp(dot(normalize(v),a),0.,1.),12.)),D+=u*mix(B*p,c,g/10.),u*=l*(1.-g/10.),C=.1;"
       "else"
         " D+=u*c,u=0.;"
     "}"
   "gl_FragColor.xyz=D;"
   "gl_FragColor.w=1.;"
 "}";

#endif // SULT_EXPECTED_
